









收藏
查看我的收藏



0
有用+1
已投票



0





























C# 4.0捷径教程
编辑
锁定



《C#4.0捷径教程》是2011年Apress出版社出版的图书，作者是(美)TreyNash。




书    名

C# 4.0捷径教程

又    名

Accelerated C# 2010


作    者

(美)Trey Nash  

ISBN

9787115243423

出版社

 Apress




目录



1
基本信息


2
内容简介


3
目录










C# 4.0捷径教程基本信息
编辑

[作译者介绍]
译者： 刘新军
丛书名： 图灵程序设计丛书
出版社：人民邮电出版社
ISBN：9787115243423
上架时间：2010-12-22
出版日期：2011 年1月
开本：16开
页码：497
版次：1-1




C# 4.0捷径教程内容简介
编辑

本书是经典教程的全面升级，通过许多精彩的示例介绍了c# 语言的每个新特性，深入浅出地讲解了c# 语言的核心概念，以及如何聪明地应用c# 的习惯用法和面向对象的设计模式来挖掘c# 和clr 的能力。这一版还介绍了c# 4.0 中新加入的动态类型，它简化了与包括com automation 对象在内的动态.net语言的集成。联合使用动态类型和expandoobject 这样的dlr 类型，你可以在c# 里创建并实现真正的动态类型，本书所探讨的技术也适用于任何针对.net 运行时的语言。
本书适合有一定编程经验的程序员阅读。




C# 4.0捷径教程目录
编辑

第1章 c#预览 1
1.1 c#和c++的区别 1
1.1.1 c# 1
1.1.2 c++ 2
1.1.3 clr垃圾回收 2
1.2 c#程序示例 3
1.3 c# 2.0新特性概览 4
1.4 c# 3.0新特性概览 5
1.5 c# 4.0新特性概览 6
1.6 小结 6
第2章 c# 和clr 8
2.1 clr中的jit编译器 8
2.2 程序集及程序集加载器 10
2.2.1 程序工作集最小化 10
2.2.2 给程序集命名 11
2.2.3 加载程序集 11
2.3 元数据 11
2.4 交叉语言的兼容性 12
2.5 小结 13
第3章 c#语法概述 14
.3.1 c#是一门强类型的语言 14
3.2 表达式 15
3.3 语句和表达式 16
3.4 类型和变量 16
3.4.1 值类型 18
3.4.2 引用类型 20
3.4.3 默认变量初始化 21
3.4.4 隐式类型化局部变量 22
3.4.5 类型转换 23
3.4.6 as和is操作符 25
3.4.7 泛型 27
3.5 命名空间 28
3.5.1 定义命名空间 28
3.5.2 使用命名空间 29
3.6 控制流 30
3.6.1 if-else、while、do-while和for 31
3.6.2 switch 31
3.6.3 foreach 31
3.6.4 break、continue、goto、return和throw 32
3.7 小结 32
第4章 类、结构和对象 33
4.1 类定义 34
4.1.1 字段 35
4.1.2 构造函数 37
4.1.3 方法 38
4.1.4 属性 39
4.1.5 封装 43
4.1.6 可访问性 46
4.1.7 接口 47
4.1.8 继承 48
4.1.9 密封类 54
4.1.10 抽象类 55
4.1.11 嵌套类 56
4.1.12 索引器 58
4.1.13 分部类 60
4.1.14 分部方法 61
4.1.15 静态类 62
4.1.16 保留的成员名字 64
4.2 值类型定义 64
4.2.1 构造函数 65
4.2.2 this的含义 66
4.2.3 终结器 69
4.2.4 接口 69
4.3 匿名类型 69
4.4 对象初始化器 72
4.5 装箱和拆箱 74
4.5.1 什么时候发生装箱 78
4.5.2 效率和混淆 79
4.6 system.object 80
4.6.1 等同性及其意义 81
4.6.2 icomparable接口 81
4.7 创建对象 82
4.7.1 new关键字 82
4.7.2 字段初始化 83
4.7.3 静态（类）构造函数 84
4.7.4 实例构造函数和创建顺序 86
4.8 销毁对象 90
4.8.1 终结器 90
4.8.2 确定性的析构 91
4.8.3 异常处理 92
4.9 可清除对象 92
4.9.1 idisposable接口 92
4.9.2 using关键字 94
4.10 方法参数类型 95
4.10.1 值参数 96
4.10.2 ref参数 96
4.10.3 out参数 98
4.10.4 参数数组 98
4.10.5 方法重载 99
4.10.6 可选参数 99
4.10.7 命名参数 100
4.11 继承和虚方法 103
4.11.1 虚方法和抽象方法 103
4.11.2 override和new方法 103
4.11.3 密封方法 105
4.11.4 关于c#虚方法再啰嗦几句 105
4.12 继承、包含和委托 106
4.12.1 接口继承和类继承的选择 106
4.12.2 委托和组合与继承 107
4.13 小结 109
第5章 接口和契约 110
5.1 接口定义类型 110
5.2 定义接口 111
5.2.1 接口中可以有什么 112
5.2.2 接口继承与成员隐藏 113
5.3 实现接口 114
5.3.1 隐式接口实现 115
5.3.2 显式接口实现 115
5.3.3 派生类中覆盖接口实现 117
5.3.4 小心值类型实现接口的副作用 120
5.4 接口成员匹配规则 121
5.5 值类型的显式接口实现 124
5.6 版本考虑 126
5.7 契约 127
5.7.1 类实现契约 127
5.7.2 接口契约 128
5.8 在接口和类之间选择 129
5.9 小结 132
第6章 重载操作符 133
6.1 可以并不意味着应该 133
6.2 重载操作符的类型和格式 133
6.3 操作符不应该改变其操作数 134
6.4 参数顺序有影响么 135
6.5 重载加法运算符 135
6.6 可重载的操作符 136
6.6.1 比较操作符 137
6.6.2 转换操作符 139
6.6.3 布尔操作符 142
6.7 小结 144
第7章 异常处理和异常安全 145
7.1 clr如何对待异常 145
7.2 c#里的异常处理机制 145
7.2.1 抛出异常 145
7.2.2 从.net 2.0开始的未处理异常的变化 146
7.2.3 try，catch和finally语句语法预览 147
7.2.4 重新抛出异常和转译异常 149
7.2.5 finally代码块抛出的异常 151
7.2.6 终结器抛出的异常 152
7.2.7 静态构造函数抛出的异常 153
7.3 谁应该处理异常 154
7.4 避免使用异常来控制流程 154
7.5 取得异常中立 155
7.5.1 异常中立代码的基本结构 155
7.5.2 受限执行区域 160
7.5.3 临界终结器和safehandle 162
7.6 创建定制的异常类 165
7.7 使用分配的资源和异常 167
7.8 提供回滚行为 170
7.9 小结 173
第8章 使用字符串 174
8.1 字符串概述 174
8.2 字符串字面量 175
8.3 格式指定和全球化 176
8.3.1 object.tostring、iformat-table和cultureinfo 176
8.3.2 创建和注册自定义cultureinfo类型 177
8.3.3 格式化字符串 179
8.3.4 console.writeline和string.format 180
8.3.5 自定义类型的字符串格式化举例 181
8.3.6 icustomformatter 182
8.3.7 字符串比较 184
8.4 处理来自外部的字符串 185
8.5 stringbuilder 187
8.6 使用正则表达式搜索字符串 188
8.6.1 使用正则表达式搜索 189
8.6.2 搜索和分组 190
8.6.3 使用正则表达式替换文本 194
8.6.4 正则表达式创建选项 196
8.7 小结 197
第9章 数组、集合类型和迭代器 198
9.1 数组介绍 198
9.1.1 隐式类型化数组 199
9.1.2 类型的转换和协方差 201
9.1.3 排序和搜索 202
9.1.4 同步 202
9.1.5 向量与数组 203
9.2 多维矩形数组 204
9.3 多维锯齿数组 206
9.4 集合类型 207
9.4.1 比较icollection[t]和icollection 207
9.4.2 集合同步 209
9.4.3 列表 209
9.4.4 字典 210
9.4.5 集合 211
9.4.6 system.collections.objectmodel 211
9.4.7 效率 213
9.5 ienumerable[t]、ienumerator[t]、ienumerable和ienumerator 214
9.6 迭代器 218
9.7 集合初始化器 226
9.8 小结 227
第10章 委托、匿名方法和事件 228
10.1 委托概览 228
10.2 委托的创建和使用 229
10.2.1 单委托 229
10.2.2 委托链 231
10.2.3 迭代委托链 232
10.2.4 非绑定（公开实例）的委托 233
10.3 事件 236
10.4 匿名方法 239
10.4.1 捕获变量与闭包 241
10.4.2 当心捕获变量的意外 243
10.4.3 匿名方法作为委托参数绑定器 246
10.5 strategy模式 248
10.6 小结 250
第11章 泛型 251
11.1 泛型和c++模板之间的区别 252
11.2 泛型的效率和类型安全 253
11.3 泛型的类型定义和构造类型 254
11.3.1 泛型类和结构 255
11.3.2 泛型接口 257
11.3.3 泛型方法 257
11.3.4 泛型委托 259
11.3.5 泛型转换 262
11.3.6 默认值表达式 263
11.3.7 nullable类型 264
11.3.8 构造类型访问权限控制 266
11.3.9 泛型和继承 266
11.4 约束 267
11.5 协变与逆变 272
11.5.1 协变 274
11.5.2 逆变 276
11.5.3 不变性 278
11.5.4 方差与委托 279
11.6 泛型系统集合 282
11.7 泛型系统接口 283
11.8 精选的问题和解决方案 284
11.8.1 泛型类型中的转化和操作符 285
11.8.2 动态地创建构造类型 293
11.9 小结 294
第12章 c#中的线程 295
12.1 c#和.net中的线程 295
12.1.1 开始线程编程 296
12.1.2 iou模式和异步方法调用 299
12.1.3 线程状态 299
12.1.4 终止线程 301
12.1.5 停止和唤醒休眠线程 303
12.1.6 等待线程退出 304
12.1.7 前台和后台线程 304
12.1.8 线程本地存储 305
12.1.9 非托管线程和com套件如何适应 308
12.2 线程间同步工作 309
12.2.1 用interlocked类实现轻量级的同步 311
12.2.2 spinlock类 316
12.2.3 monitor类 317
12.2.4 锁对象 325
12.2.5 信号量 329
12.2.6 事件 331
12.2.7 win32的同步对象和waithandle 332
12.3 使用线程池 334
12.3.1 异步方法调用 335
12.3.2 定时器 341
12.4 并发编程 343
12.4.1 task类 343
12.4.2 parallel类 345
12.4.3 线程池的简单入口 349
12.4.4 线程安全集合类 350
12.5 小结 350
第13章 c#规范形式探索 351
13.1 引用类型的规范形式 351
13.1.1 类默认是密封的 352
13.1.2 使用非虚拟接口（nvi）模式 353
13.1.3 对象是否可克隆 355
13.1.4 对象是否可清除 360
13.1.5 对象需要终结器吗 362
13.1.6 对象相等意味着什么 368
13.1.7 如果重写了equals方法，那么也应该重写gethashcode方法 374
13.1.8 对象支持排序吗 377
13.1.9 对象需要形式化显示吗 379
13.1.10 对象可以被转换吗 382
13.1.11 在所有情况下都保证类型安全 384
13.1.12 使用非可变的引用类型 387
13.2 值类型的规范形式 389
13.2.1 为了获得更好的性能而重写equals方法 390
13.2.2 值类型需要支持接口吗 394
13.2.3 将接口成员和派生方法实现为类型安全的形式 394
13.3 小结 397
13.3.1 引用类型的检查单 397
13.3.2 值类型的检查单 398
第14章 扩展方法 399
14.1 扩展方法介绍 399
14.1.1 编译器如何发现扩展方法 400
14.1.2 探究内部实现 403
14.1.3 代码易读性与代码易懂性 403
14.2 使用建议 404
14.2.1 考虑扩展方法优先于继承 404
14.2.2 分离的命名空间中的隔离扩展方法 405
14.2.3 修改一个类型的契约可能会打破扩展方法 406
14.3 转换 406
14.4 链式操作 410
14.5 自定义迭代器 411
14.6 访问者模式 417
14.7 小结 420
第15章 lambda表达式 422
15.1 lambda表达式介绍 422
15.1.1 lambda表达式与闭包 423
15.1.2 lambda语句 427
15.2 表达式树 428
15.2.1 对表达式的操作 430
15.2.2 函数的数据表现 431
15.3 lambda表达式的有益应用 431
15.3.1 迭代器和生成器重访问 432
15.3.2 再谈闭包（变量捕获）和缓存 435
15.3.3 currying 439
15.3.4 匿名递归 441
15.4 小结 442
第16章 linq：语言集成查询 443
16.1 连接数据的桥梁 443
16.1.1 查询表达式 444
16.1.2 再谈扩展方法和lambda表达式 446
16.2 标准查询操作符 446
16.3 c#查询关键字 448
16.3.1 from子句和范围变量 448
16.3.2 join子句 449
16.3.3 where子句和过滤器 451
16.3.4 orderby子句 451
16.3.5 select子句和投影 452
16.3.6 let子句 454
16.3.7 group子句 455
16.3.8 into子句和持续性 458
16.4 偷懒的好处 459
16.4.1 c#迭代器鼓励懒惰 459
16.4.2 不能偷懒 460
16.4.3 立即执行查询 462
16.4.4 再谈表达式树 462
16.5 函数式编程中的技术 462
16.5.1 自定义标准查询操作符和延迟求值 463
16.5.2 替换foreach语句 469
16.6 小结 471
第17章 dynamic类型 472
17.1 dynamic意味着什么？ 472
17.2 dynamic如何工作？ 474
17.2.1 大统一 476
17.2.2 调用站 476
17.2.3 具有自定义动态行为的对象 478
17.2.4 效率 480
17.2.5 dynamic装箱 482
17.3 dynamic转换 482
17.4 动态重载解析 485
17.5 dynamic继承 486
17.5.1 不能派生自dynamic 486
17.5.2 不能实现动态接口 487
17.5.3 可以派生自dynamic基类 489
17.6 c#里的推断类型 490
17.7 dynamic类型的限制 493
17.8 expandoobject：动态地创建对象 493
17.9 小结 497

词条标签：


书籍





